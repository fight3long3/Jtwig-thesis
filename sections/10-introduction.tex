-\chapter{Introduction}

Sir Tim Berners-Lee published the proposal for the World Wide Web, commonly referred as \textbf{Web}, in 1989 \cite{Berners-Lee1989InformationProposal}. At that time Tim was not predicting how spread and important his creation would be. Although initially rejected, his proposal laid three fundamental building blocks for the web today:

\begin{itemize}
    \item HTTP: Hypertext Transfer Protocol. Allows for the retrieval of linked resources from across the web.
    \item URI: Uniform Resource Identifier, also commonly called a URL, allows to uniquely identity a resource on the entire web.
    \item HTML: HyperText Markup Language. The markup (formatting) language for the web, allowing to write, the so called, \textit{web pages}.
\end{itemize}

Tim also wrote the \textit{WorldWideWeb}, an HTML editor and visualisation tool \cite{Gillies2000HowWeb}, which is known to be the first ever built Browser for the web.

Since then web has evolved, it spread across the globe and is being used as a fundamental resource for communication nowadays. The usage of HTML specifically also evolved, it started with simple static content and became a dynamic, customizable and personalizable way of reaching out to people.

At the same time this evolution was taking place, existing concepts were being applied to this new world. An example of that is the MVC (Model View Controller) design pattern used to develop user facing applications.

\section{MVC}

Model View Controller is one of the most used patterns for web development. It was developed by Trygve Reenskaug for Smalltalk late in the 1970s \cite{Reenskaug1979THING-MODEL-VIEW-EDITORPlanningsystem} and it influenced most UI frameworks since then \cite{Fowler2003PatternsArchitecture}.

It is important to remind the reader that this pattern was drafted long before Web was invented, therefore, the concept required some modifications in order to be applicable to the web architecture.

\subsection{Original MVC}

The original MVC was built in a time where applications used to take control over both input and output devices. It was created with the main goal of bridging the gap between the user mental model and the digital model maintained by the system. A central component in this pattern is the Model, which represents the knowledge of the system, usually backed by a source of data (database). This is the digital representation of the information on the system. To allow the user to interact with this digital knowledge, two concepts were defined, they are the View and the Controller. The View is a visual representation of the Model or parts of it and is responsible of interacting with the Model in order to gather data to be shown also as update it. The Controller is the bridge between the user input and the system. It is also responsible of organising the views in a proper manner \cite{Reenskaug1979THING-MODEL-VIEW-EDITORPlanningsystem}.


\subsection{Benefits of MVC}

The main benefit of adopting MVC when developing user facing applications it’s the separation of concerns it embodies. The Model and View address two completely distinct domains, while the Model takes care of the business rules, the View addresses the mechanisms of the UI. The Controller is commonly seen as the bridge between View and Model. This approach makes the View dependent on the Model, but that dependency doesn’t exist in reverse, that means, the Model is independent from the View. This means, people developing the Model can be completely unaware of the View implementation \cite{Parr2008TheSeparation, Parr2004EnforcingEngines, Fowler2003PatternsArchitecture}.

Splitting the business logic and display logic domains in an application allows it to have different people with a distinct set of skills addressing each layer individually, making it easier to maintain \cite{Parr2008TheSeparation}.

\subsection{Web MVC}

As per Martin Fowler \cite{Fowler2003PatternsArchitecture} definition, the adoption of MVC on the Web suffers a slight adaptation when compared to the original MVC pattern. The Model concept still accounts for the representation of the knowledge, however the View is only about displaying information on the UI. All the changes in the Model are performed by the Controller component. The controller bridges the gap between the user requests and system, also taking care of updating the views accordingly.

\subsubsection{Controller}

There are multiple ways to approach the Controller layer in an MVC pattern within Web Development. The most commonly used are Page Controller and Front Controller. In the first one, each page or action have a specific handler, where in the later there is one handler managing and routing all the incoming requests, usually the Front Controller approach delegates to specific handlers making both Page and Front Controller very similar \cite{Fowler2003PatternsArchitecture}. 

\subsubsection{View}

One of the most seen approaches for the View in Web development is the Template View. This approach used in the display stage of the MVC pattern can be summarised as a way to embed markers in HTML files, this markers are then processed and replaced by the result of their computation \cite{Fowler2003PatternsArchitecture}. Templates will be detailed later on this chapter.

\section{Java}

Java technology is both a programming language and a platform \cite{firstcup}. Java is an high-level object-oriented language which gets compiled to a pseudo-binary code (named bytecode) which is interpreted by a Java Platform. A Java Platform consist of a Java Virtual Machine (JVM) and an application programming interface (API). Code written in Java uses this API and runs on the JVM. Distinct platforms   were then published, with the intention to address different needs, namely:

\begin{itemize}
	\item Java SE (Standard Edition), this Platform specifies the most common API, it defines everything from the basic types and objects to the high level classes used for networking, security, database access and so on. This Platform is what usually runs on personal computers.
	\item Java EE (Enterprise Edition), the enterprise edition is built on top of the Java SE with additions to allow running large-scale, multi-tiered, scalable, reliable and secure network applications \cite{OracleJavaPlatform}.
	\item Java ME (Micro Edition), is a small-footprint Platform for small devices, like mobile phones.
\end{itemize}

\subsection{Java EE}

Java Enterprise Edition, initially, J2EE (Java 2 Platform, Enterprise Edition) specification is available under the JSR (Java Specification Request) 58. This platform was created with the intention to reduce the cost and complexity of developing multi-tier services \cite{SunMicrosystemsJSRSpecification}, \cite{SunMicrosystems200JavaGuide}, \cite{Bloch2008EffectiveSeries}. 

Under the context of Java EE, a web tier was designed to support the development of web applications. It is a set of components which handle the interaction between clients and the business logic, it consists mainly on the Servlet and JSP (JavaServer Pages) APIs \cite{Mordani2003JSRSpecification, Mordan2009JSRSpecification, waiChan2013JSRSpecification}.

However an initial step towards standardisation, Java EE had issues. As \cite{Johnson2005ProfessionalFramework} identifies, Java EE applications were complex, took excessive effort to develop and exhibit disappointing performance.

In order to address this problems, two main approaches were being used, (1) code generation tools and (2) frameworks. While the first addresses the complexity by creating a shortcut for development without removing any of the complexity, the second approach allows for a coherent and simplified abstraction, thus making the framework approach much more attractive for developers in general.

\subsection{Framework}

A framework is a general skeleton for a software application \cite{Liu1996SmalltalkDesign}. On the object oriented world, they typically serve to implement (larger scale) components using user provided (smaller scale) classes \cite{Riehle200FrameworkApproach}. In technical terms, it can be seen as a body of code which can be reused in different projects \cite{Liu1996SmalltalkDesign}, systems based on frameworks are easier to maintain because most of the key design and implementation decisions are localised in the framework itself.  On the business side, frameworks allow higher productivity and shorter time-to-market for new applications \cite{Riehle200FrameworkApproach}.
An example of a Framework in the Java world is the Spring Framework.

\subsection{Spring Framework}

The first version of the Spring framework was written by Rod Johnson and it was released with the publication of his book Expert One-on-One J2EE Design and Development \cite{Johnson2003ExpertDevelopment}. Spring Framework is the first lightweight framework to address all architectural tiers of a typical Java EE application. ightweight frameworks enable developers to work with POJOs (Plain Old Java Objects) rather than having to follow strict conventions, as for example, Enterprise Java Beans (EJB) \cite{SunMicrosystemsJSRSpecification, Johnson2005ProfessionalFramework, Johnson2003ExpertDevelopment}. As defined by the Java EE API, an EJB class must obey to the following rules:

\begin{itemize}
	\item implement either Serializable or Externalizable;
	\item have a public no-arg constructor;
	\item all properties must have public setter and getter methods (as appropriate);
	\item all instance variables should be private;
\end{itemize}
h
Below there is an example of an EJB.

\lstinputlisting[language=Java, caption=]{code/introduction/PersonBean.java}

As one can see, the example above follows the conventions mentioned before. Lightweight frameworks remove the need for this boiler plate code by using POJOs. A POJO can be seen as a class without rules, it does not need to follow any of the Java object models or conventions, therefore enabling developers to focus on the business logic.

Spring can be divided into distinct modules, in summary:

\begin{review}
\begin{itemize}
	\item \textbf{Inversion of Control Container} The core "container" Spring provides, enabling sophisticated configuration management for POJOs and work with other parts of Spring.
	\item \textbf{Aspect-Oriented Programming (AOP) framework} AOP enables behavior that would otherwise be scattered through different methods to be modularized in a single place. Spring uses AOP under the hood to deliver important out-of-the-box services such as declarative transaction management. Spring AOP can also be used to implement custom code that would otherwise be scattered between application classes.
	\item \textbf{Data access abstraction} Spring encourages a consistent architectural approach to data access, and provides a unique and powerful abstraction to implement it. Spring provides a rich hierarchy of data access exceptions, independent of any particular persistence product. It also provides a range of helper services for leading persistence APIs, enabling developers to write persistence framework–agnostic data access interfaces and implement them with the tool of their choice.
	\item \textbf{JDBC simplification} Spring provides an abstraction layer over JDBC that is significantly simpler and less error-prone to use than JDBC when you need to use SQL-based access to relational databases.
	\item \textbf{Transaction management} Spring provides a transaction abstraction that can sit over JTA "global" transactions (managed by an application server) or "local" transactions using the JDBC, Hibernate, JDO, or another data access API. This abstraction provides a consistent programming model in a wide range of environments and is the basis for Spring's declarative and programmatic transaction management.
	\item \textbf{Simplification for working with JNDI, JTA, and other J2EE APIs} Spring can help remove the need for much of the verbose, boilerplate code that "doesn't do anything." With Spring, you can continue to use JNDI or EJB, if you want, but you'll never need to write another JNDI lookup. Instead, simple configuration can result in Spring performing the lookup on your behalf, guaranteeing that resources such as JNDI contexts are closed even in the event of an exception. The dividend is that you get to focus on writing code that you need to write because it relates to your business domain.
	\item \textbf{Lightweight remoting} Spring provides support for POJO-based remoting over a range of protocols, including RMI, IIOP, and Hessian, Burlap, and other web services protocols.
	\item \textbf{JMS support} Spring provides support for sending and receiving JMS messages in a much simpler way than provided through standard J2EE.
	\item \textbf{JMX support} Spring supports JMX management of application objects it configures.
	\item \textbf{MVC web framework} Spring provides a request-based MVC web framework which integrates seamlessly with the Spring IoC container. 
\end{itemize}
\end{review}

Please refer to \cite{Johnson2005ProfessionalFramework} for futher details on each of the modules. For the purpose of this study one will focus on the MVC framework. This MVC frameworks take advantage of the Front Controller approach and set one handler which then routes the requests to smaller components. This Frameworks ease the initial setup and work of developing web applications providing APIs for different purposes, one of those is the integration with a Template View approach.

One of the many options Spring offers is the ability to integrate a Template mechanism.

\section{Templates}

When it comes to web development, templates can take a key role as mentioned before, specially when addressing the View component on an MVC designed application. In regards to templates, however only recently applied in many scientific areas, the concept is not that recent, in fact it can tracked back early in the \texttt{XIX} century.

\subsection{Meaning \& Etymology}

In \textit{The Century Dictionary} \cite[p.6224]{Whitney1906TheDictionary}, \texttt{template} entry is just pointing to the \texttt{templet} definition, which is used as the main entry for this concept. Below, there is an excerpt taken from page 6224 of this book.

\begin{bookQuote}
     \textbf{Templet} 
     
     \begin{enumerate}
         \item A pattern, guide, or model used to indicate the shape any piece of work is to assume when finished. It may also be used as a tool in modelling plastic material, or as a guide placed in a milling-machine, shaper-lathe or other automatic cutting-machine. In these applications it maybe a thin piece of wood or metal, with one or all the edges cut in profile to the shape of the baluster, cornice, part of a machine, or other object to be wrought to shape. Templets are also used as guides in filing sheet-metal to shape, as in making small brass gears for clocks, sheets of brass being clamped between steel templets, and all the parts projecting beyond the edges being flied away. Templets are used in founding as patterns in forming moulds in loam.
         
         \item A strip of metal used in boiler-making, pierced with a series of holes, and serving as a guide in marking out a line of rivet-holes.
         \item In building: (a) A short piece of timber or a large stone placed in a wall to receive the impost of a girder, beam, etc., and distribute its weight. (b) A beam or plate spanning a door or window-space to sustain joists and throw their weight on the piers. (c) One of the wedges in a building-block.
         \item Same as temple
         \item In a brilliant, same as bezel
     \end{enumerate}
\end{bookQuote}

According to \cite{Barnhart1988TheEtymology} \texttt{Template} ending was created in the mid \texttt{XIX} century and was due to the association with plate. 

From here, we can easily see that the concept of template exists long before web was invented, even long before programmable computers were invented \cite{Clements2014ComputerVariations}, however, the intent for optimisation was and still is a major characteristic of this technique.

\subsection{Text Processing}

Back to modern days, when the goal is to generate text using programming languages, some might still remember the character manipulation required in some classic languages. This is becoming increasingly easy with the most recent languages, however, creating and concatenating string constructs are still a painful way of generating large quantities of text \cite{Fowler2003PatternsArchitecture}, this lead to the introduction of templates as a concept in the text processing world.

One observed evolution in programming languages and, at the same time, one of the most basic forms of templates, is the string interpolation mechanism. Perl was one of the first languages to provide native support to it \cite{Wall2000ProgrammingPerl}, below there is an example on how to do it in Perl.

\begin{lstlisting}[language=Perl]
my $time = now();
print "Current time is $time";
\end{lstlisting}

In this example, the string can be divided in two parts, one static part and another dynamic. The dynamic part is the variable \texttt{\$time}, whether the static part is the rest. With this approach is possible to specify variables as part of a string construct. In fact, many recent languages support string interpolation, pretty much in the same way as Perl. 

Generically speaking, templates can be used to take advantage of a text pattern with dynamic constructs and generate instances of text. A template, therefore, can be seen as a function with one parameter - a configuration (commonly referred as \textbf{data model}) - which produces text as output. 

\begin{center}
$Template := Configuration \rightarrow Text$
\end{center}

\begin{orientador}
    Should I detail the formal definition of Template based on \cite{Parr2004EnforcingEngines} or just refer it?
\end{orientador}

In order to specify a template, a language is required, this is commonly referred as the \textit{Template Language}. Template languages have an inverted approach when compared to common programming languages, that is, programming languages allow developers to embed string definitions (text) in it, like Perl, for example, as shown before, whether, template languages are embedded in the text.

Of course, a template instance on it's own is not enough to produce content. Associated with a template language there is always an engine to process it, so called, \textit{Template Engine}. This engine is an application which applies the template to a specific configuration generating, therefore, text as output.

\begin{center}
    $TemplateEngine := Template \times Configuration \rightarrow Text$
\end{center}

Wikipedia collected \cite{WikipediaComparisonEngines} until the current date, an incomplete list of, approximately, 100 distinct template engines with associated languages. Between them, one can find, for example, \textbf{Mustache} \cite{mustache} and freemarker \cite{Forsythe2013InstantFreemarker}.

\subsection{Mustache}

\begin{review}
Mustache is presented to the community as a "logic-less" template engine. It is called "logic-less" because there are no if statements, else clauses, or for loops. Instead there are only tags. Some tags are replaced with a value, some nothing, and others a series of values. 
Tags are indicated by the double curly brakets. For example, \texttt{\{\{person\}\}} is a tag, as is \texttt{\{\{#person\}\}}. In both examples, one could refer to person as the key or tag key. The possible tags are:

\begin{itemize}
    \item Variable \todo
    \item Section \todo
    \item Inverted Sections \todo
    \item Partials \todo
\end{itemize}

Mustache is a good example of a simple template engine which attempts to reduce template complexity by limiting developers. It tries to get away from the concept of control flow and, instead, present developers the concept of tags, tags can adopt different behaviour depending on the context.

\begin{expand}
    Expand mustache in order to introduce "the problem"
\end{expand}
\end{review}

\subsection{Freemarker}

\begin{review}
Apache FreeMarker is a template engine: a Java library to generate text output (HTML web pages, e-mails, configuration files, source code, etc.) based on templates and changing data. Templates are written in the FreeMarker Template Language (FTL), which is a simple, specialized language (not a full-blown programming language like PHP). You meant to prepare the data to display in a real programming language, like issue database queries and do business calculations, and then the template displays that already prepared data. In the template you are focusing on how to present the data, and outside the template you are focusing on what data to present.

\begin{expand}
    More details about freemarker, giving space for presenting "The Problem"
\end{expand}
\end{review}

\section{The Problem}

There is already a set of template technologies available in the market for the Java World, however, \claim{existing solutions have some limitations}, more specifically, \claim{long learning curve}, \claim{poor readability}, \claim{poor extendability} and, for some of them, \claim{poor expressing power}. 

\begin{expand}
    Show evidences of previous claims using the previousy mentioned template engines.
\end{expand}

\begin{expand}
    Talk about the consequences of the problems identified.
\end{expand}

\section{The Proposed Solution}

Given this, one decided to come up with a solution that could, potentially, address all of this problems, therefore, creating an alternative with capabilities not yet available in the market. This means:


\begin{orientador}
    How much detail should I give about the solution we are proposing to develop?
\end{orientador}